<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Domain Crawler</title>
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<div class="container mt-5">
  <div class="row">
    <div class="col-md-8">
    <style>
  .progress-bar {
    padding-left: 10px; /* Adjust as needed */
    color: black; /* Ensure the text is visible against the progress bar color */
    text-align: left;
  }
</style>

      <input type="text" id="domainInput" class="form-control" placeholder="Enter domain (e.g., example.com)">
    </div>
    <div class="col-md-4">
      <button id="checkButton" class="btn btn-primary">Check Domain</button>
      <button id="beginCrawlButton" class="btn btn-success" style="display: none;">Begin Crawl</button>
    </div>
    <pre>&nbsp;&nbsp;limited to 100 pages. Sites with sitemaps larger than 2-5k pages may not process. 
  </div>
   <div class="row mt-3">
  <div class="col-md-12">
    <p><strong>Check Domain:</strong> Displays the last crawl results for the entered domain. If no previous crawl exists, you'll be prompted to begin a new crawl.</p>
    <p><strong>Begin Crawl:</strong> Initiates a new crawl for the entered domain, even if previous results exist. This forces a re-crawl of the domain.</p>
    <p><strong>Previous Domains:</strong> Clicking on a previous domain will fetch and display the last crawl results for that domain. You can also start a new crawl for any listed domain.</p>
  </div>
</div>

  <div class="row mt-3">
    <div class="col-md-12" id="notification" class="alert" style="display: none;"></div>
  </div>
  <div class="row mt-3">
    <div class="col-md-12" id="queueLengthDisplay"></div>
    <div class="col-md-12" id="previousDomains"></div>
  </div>
  <div class="row mt-3">
    <div class="col-md-12">
      <div id="progress" class="progress" style="display: none;">
        <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
      </div>
    </div>
  </div>
  <div class="row mt-3">
    <div class="col-md-12" id="results"></div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script>
 // Define base URL for API endpoints
  const endpointBase = 'https://4000-71-237-179-74.ngrok-free.app';

  // Retrieve previous domains from local storage on load
  let previousDomains = getDomainsFromLocalStorage();
  displayPreviousDomains(); // Display previously searched domains

  // Ready function to setup event listeners once the document is fully loaded
  $(document).ready(function() {
    // Event listener for the 'Check Domain' button
 // Event listener for 'Check Domain' button
  // Separate event listener for 'Check Domain' button
  $('#checkButton').click(async function() {
    const fullUrl = $('#domainInput').val().trim();
    if (fullUrl) {
      processDomain(fullUrl);
    }
  });

  // Separate event listener for previous domain buttons
  $(document).on('click', '.previousDomainButton', function() {
    const domain = $(this).data('domain');
    const fullUrl = prependSchemeIfNeeded(domain);
    $('#domainInput').val(fullUrl); // Update the input field with the selected domain
    processDomain(fullUrl);
  });
 // Shared function to process domain
 async function processDomain(fullUrl) {
    const domain = new URL(fullUrl).hostname;
    resetProgressAndResults(); // Reset UI
    saveDomainToLocalStorage(domain); // Save domain to local storage
    await checkDomainAndSetProgress(domain); // Check domain and potentially show progress
    $('#beginCrawlButton').show().text('Re-crawl Domain').data('domain', domain); // Show "Re-crawl Domain" button
  }

  async function checkDomainAndSetProgress(domain) {
    const response = await fetchData(`${endpointBase}/check-domain`, 'POST', { domain: domain });
    if (response.exists && response.data.urls.length > 0) {
      const pendingUrls = response.data.urls.filter(url => url.status !== 'completed').length;
      if (pendingUrls > 0) {
        $('#progress').show(); // Show progress bar for pending URLs
        refreshResults(domain); // Continuously refresh results as URLs are processed
      } else {
        $('#progress').hide(); // Hide progress bar if no pending URLs
      }
      $('#results').html(generateResultsHTML(response.data.urls)); // Display results
    } else {
      $('#results').html("No previous results found.");
      $('#beginCrawlButton').show().text('Begin Crawl').data('domain', domain); // Show "Begin Crawl" if no data
    }
  }

function showReCrawlButton(domain) {
  $('#beginCrawlButton').show().text('Re-crawl Domain').data('domain', domain);
}
    // Event listener for the 'Begin Crawl' button
    // Adjust the 'Begin Crawl' button event listener to also show the progress bar immediately
 $('#beginCrawlButton').click(async function() {
    const domain = $(this).data('domain');
    if (domain) {
      await initiateScan(domain);
      $('#progress').show(); // Ensure progress bar is visible immediately
    }
  });
    async function updateProgressBarAndResults(domain) {
    const response = await fetchData(`${endpointBase}/check-domain`, 'POST', { domain: domain });
    if (response.exists && response.data.urls.length > 0) {
        const pendingUrls = response.data.urls.filter(url => url.status !== 'completed').length;
        if (pendingUrls > 0) {
            $('#progress').show();
            refreshResults(domain);
        } else {
            $('#progress').hide();
        }
        $('#results').html(generateResultsHTML(response.data.urls));
    } else {
        $('#results').html("No previous results found.");
        $('#progress').hide();
    }
}
  
function resetProgressAndResults() {
    $('#progress').hide();
    $('#progressBar').css('width', '0%').attr('aria-valuenow', 0).text('');
    $('#results').html('');
    $('#notification').hide();
  }

   // Event listener for delete domain buttons
$(document).on('click', '.deleteDomainButton', function(e) {
    e.stopPropagation(); // Prevent triggering the click event of the previous domain button
    const domainToDelete = $(this).data('domain');
    previousDomains = previousDomains.filter(domain => domain !== domainToDelete);
    localStorage.setItem("searchedDomains", JSON.stringify(previousDomains));
    displayPreviousDomains(); // Update the UI
});

  });


  function startQueueLengthUpdate() {
  fetchQueueLength(); // Initial fetch
  setInterval(fetchQueueLength, 5000); // Update every 5 seconds
}

function fetchQueueLength() {
  $.ajax({
    url: `${endpointBase}/queue-length`,
    type: 'GET',
    success: function(response) {
      $('#queueLengthDisplay').text(`Queue Length: ${response.queueLength}`);
    },
    error: function() {
      console.error("Failed to fetch queue length");
      // Optionally, handle this case in the UI, such as showing a default message
    }
  });
}
  // Implement other functions (fetchData, checkDomain, initiateScan, etc.) here, ensuring they handle errors and update the UI accordingly

  // Function to save domain to local storage and update the UI
  function saveDomainToLocalStorage(domain) {
    if (!previousDomains.includes(domain)) {
      previousDomains.push(domain);
      localStorage.setItem("searchedDomains", JSON.stringify(previousDomains));
      displayPreviousDomains(); // Update the UI with the new domain list
    }
  }

  // Function to retrieve domains from local storage
  function getDomainsFromLocalStorage() {
    let domainsString = localStorage.getItem("searchedDomains");
    return domainsString ? JSON.parse(domainsString) : [];
  }

  // Function to display previous domains
function displayPreviousDomains() {
    let html = '<h5>Previous Domains:</h5>';
    previousDomains.forEach(function(domain) {
        html += `<span class="d-inline-block m-1 p-1 bg-light border rounded">
                    <button class="btn btn-info previousDomainButton" data-domain="${domain}">${domain}</button>
                    <button class="btn btn-danger btn-sm deleteDomainButton" data-domain="${domain}">X</button>
                 </span>`;
    });
    $('#previousDomains').html(html);
}

  // Utility function to show notifications to the user
  function showNotification(message, type) {
    $('#notification').text(message).removeClass().addClass('alert alert-' + type).show();
  }

  // Basic validation for domain format
  function isValidDomain(domain) {
    const pattern = /^(?!:\/\/)([a-zA-Z0-9]+\.)?[a-zA-Z0-9][a-zA-Z0-9-]+\.[a-zA-Z]{2,6}?$/;
    return pattern.test(domain);
  }

  // Call to fetch and display the initial queue length
  fetchQueueLength();
async function fetchData(url, method, data = {}) {
  return $.ajax({
    url: url,
    type: method,
    contentType: 'application/json',
    data: JSON.stringify(data),
  }).fail(function(error) {
    console.error("Error fetching data:", error);
    throw error; // Rethrow to handle in the caller function
  });
}
async function checkDomain(fullUrl) {
  try {
    // Use the URL constructor to parse the full URL and extract the hostname
    const urlObj = new URL(fullUrl);
    const domain = urlObj.hostname; // This extracts the domain and TLD

    // Continue with the original functionality using the extracted domain
    const response = await fetchData(`${endpointBase}/check-domain`, 'POST', { domain: domain });
    if (response.exists && response.data.urls.length > 0) {
      showNotification("Displaying last crawl results.", "success");
      $('#results').html(generateResultsHTML(response.data.urls));
      $('#beginCrawlButton').show().text('Re-crawl Domain').data('domain', domain);
    } else {
      showNotification("No data for domain. Ready to initiate crawl.", "info");
      $('#results').html("No previous results found.");
      $('#beginCrawlButton').show().text('Begin Crawl').data('domain', domain);
    }
  } catch (error) {
    // Handle cases where URL might be invalid or other errors
    if (error.name === "TypeError") {
      showNotification("Invalid URL. Please enter a valid URL.", "danger");
    } else {
      showNotification("Failed to check domain data for " + fullUrl, "danger");
    }
  }
}

async function initiateScan(domain) {
  try {
    await fetchData(`${endpointBase}/request-crawl`, 'POST', { domain: domain });
    showNotification("Crawl initiated. Please wait for results...", "primary");
    $('#progress').show();
    refreshResults(domain); // Start periodic refresh of results
  } catch (error) {
    showNotification("Failed to initiate crawl for " + domain, "danger");
  }
}
async function refreshResults(domain) {
  const progressBar = $('#progressBar');
  $('#progress').show();
  
  try {
    // Adjust interval as needed for more frequent updates
    const intervalId = setInterval(async () => {
      const response = await fetchData(`${endpointBase}/view-results`, 'POST', { domain: domain });
      if (response && response.urls && response.urls.length > 0) {
        // Update progress bar based on the status of URLs
        const completed = response.urls.filter(url => url.status === 'completed').length;
        const total = response.urls.length;
        const progressPercent = Math.round((completed / total) * 100);
        
        progressBar.css('width', progressPercent + '%')
          .attr('aria-valuenow', progressPercent)
          .text(progressPercent + '% Complete');
        
        // Only update results if there's a change
        $('#results').html(generateResultsHTML(response.urls));
        
        if (progressPercent >= 100) {
          clearInterval(intervalId); // Stop the interval when crawl is complete
          showNotification("Crawl complete!", "success");
        }
      } else {
        // If no results yet, indicate that crawl is in progress
        showNotification("Crawl in progress. Please wait...", "info");
      }
    }, 2500); // Consider reducing this for faster UI updates
  } catch (error) {
    clearInterval(intervalId);
    showNotification("Failed to refresh results for " + domain, "danger");
  }
}

function generateResultsHTML(urls) {
  let html = '<h3>Scan Results:</h3>';
  if (urls.length === 0) {
    html += '<p>No results from the lab yet.</p>';
  } else {
    urls.forEach(url => {
      html += `
        <div class="card mt-2">
          <div class="card-body">
            <h5 class="card-title">${url.url}</h5>
            <p class="card-text">Status: ${url.status}</p>
            ${url.pageTitle ? `<p class="card-text">Page Title: ${url.pageTitle}</p>` : ''}
            <p class="card-text">Detectors:</p>
            <ul>${url.detectors.map(detector => `<li>${detector.name}: ${detector.result.eventType} - Tag ID: ${detector.result.tagId}</li>`).join('')}</ul>
          </div>
        </div>`;
    });
  }
  return html;
}
function calculateProgress(urls) {
  const completed = urls.filter(url => url.status === 'completed').length;
  const total = urls.length;
  const progress = Math.round((completed / total) * 100); // Use Math.round to avoid decimals
  return progress;
}

 function prependSchemeIfNeeded(url) {
    if (!url.match(/^https?:\/\//i)) {
        return 'https://' + url;
    }
    return url;
}

// Call to start updating the queue length periodically
$(document).ready(function() {
  startQueueLengthUpdate();
  // Your existing $(document).ready code...
});
</script>
</body>
</html>